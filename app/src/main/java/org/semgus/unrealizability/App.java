/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package org.semgus.unrealizability;

import com.microsoft.z3.*;
import org.semgus.java.object.SmtTerm;
import org.semgus.java.object.TypedVar;
import org.semgus.java.problem.ProblemGenerator;
import org.semgus.java.problem.SemgusProblem;

import java.io.FileReader;
import java.io.Reader;
import java.util.*;

public class App {
    public static void main(String[] args) {
        com.microsoft.z3.Global.ToggleWarningMessages(true);
        SemgusProblem problem;
        try (Reader reader = new FileReader(args[0])) {
            problem = ProblemGenerator.parse(reader);
        } catch (Exception ex) {
            ex.printStackTrace();
            return;
        }

        Context ctx = new Context();
        var parser = new SemgusProblemParser(ctx);
        var constraints = parser.parseProductions(problem);
        constraints.forEach(System.out::println);
        //System.out.println(problem.dump());

        //smallTest();

        //System.out.println(problem.smtContext());
    }

    static void smallTest() {
        Context ctx = new Context();
        IntSort Z = ctx.getIntSort();
        BoolSort B = ctx.getBoolSort();

        var S = ctx.mkFuncDecl("S", Z, B);
        var x = ctx.mkIntConst("x");
        var xp = ctx.mkIntConst("xp");
        var o = ctx.mkIntConst("o");
        var i = ctx.mkIntConst("i");

        var two = ctx.mkInt(2);
        var S_x = ctx.mkApp(S, x);

        var c1 = ctx.mkImplies(ctx.mkEq(x, ctx.mkInt(0)), S_x);
        var c2 = ctx.mkImplies(ctx.mkAnd(
                ctx.mkEq(x, ctx.mkAdd(xp, ctx.mkInt(3))),
                S.apply(xp)
        ), S_x);
        var c3 = S.apply(o);
        var c4 = ctx.mkEq(o, ctx.mkAdd(two, ctx.mkMul(two, i)));

        var rules = ctx.mkAnd(c1, c2, c3, c4);
        var boundedRules = ctx.mkForall(new IntExpr[]{x, xp, i}, rules, 1, null, null, null, null);
        System.out.println(boundedRules);

        var SDefinition = ctx.mkForall(new IntExpr[]{x, xp}, ctx.mkImplies(
                ctx.mkOr(
                        ctx.mkEq(x, ctx.mkInt(0)),
                        ctx.mkAnd(
                                S.apply(xp),
                                ctx.mkEq(x, ctx.mkAdd(ctx.mkInt(3), x))
                        )
                ),
                S.apply(x)
                ), 1, null, null, null, null);

        var solver = ctx.mkSolver("HORN");

        //solver.assertAndTrack(rules, ctx.mkBoolConst("C1"));
        //var result = solver.check(ctx.mkNot(SDefinition));
        var result = solver.check(boundedRules);
        System.out.println(result);
        if (result == Status.SATISFIABLE)
            System.out.println(solver.getModel());
        else if (result == Status.UNSATISFIABLE)
            System.out.println(Arrays.toString(solver.getUnsatCore()));
    }

    static void chcTest() {
        Context ctx = new Context();
        IntSort Z = ctx.getIntSort();
        BoolSort B = ctx.getBoolSort();

        FuncDecl<BoolSort> f = ctx.mkFuncDecl("f", new Sort[]{Z, Z}, B);

        Expr<IntSort> x = ctx.mkConst("x", Z);
        Expr<IntSort> y = ctx.mkConst("y", Z);
        Expr<IntSort> z = ctx.mkConst("z", Z);

        var solver = ctx.mkSolver("HORN");

        BoolExpr C1 = ctx.mkForall(
                new Expr[] {x},
                ctx.mkImplies(
                        ctx.mkGt(x, ctx.mkInt(100)),
                        f.apply(x, ctx.mkSub(x, ctx.mkInt(10)))
                ),
                1, null, null, ctx.mkSymbol("C1"), null);

        solver.add(C1);
        var result = solver.check();
        System.out.println(result);
        var model = solver.getModel();
        System.out.println(model);
    }
}
